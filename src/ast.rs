// MIT License
//
// Copyright (c) 2018 Hans-Martin Will
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use super::schema;
use super::types;

use std::collections;
use std::iter;
use std::mem;
use std::ops;

/// The error value; currently this is just a string
pub type Error = super::Error;

/// SQL statements that are supported by this implementation
pub enum SqlStatement {
    /// A regular (DML) statement
    Statement(Statement),

    /// Query plan analysis
    ExplainQueryPlan(Statement),

    /// Attach an external file as source for query processing
    Attach(AttachStatement),

    /// Describe a particular schema object
    Describe(DescribeStatement),
}

pub enum Statement {
    Select(SelectStatement),
    Insert(InsertStatement),
    Delete(DeleteStatement),
    Update(UpdateStatement),
}

/// Representation of an insert statement
pub struct InsertStatement {
    /// the name of the table into which we want to insert new values
    pub table_name: Vec<String>,

    /// an optional list of columns that define a mapping between the provided values and the columns
    /// defined in the table
    pub columns: Option<Vec<String>>,

    /// An expression that will yield the rows to insert
    pub source: Box<SetExpression>,
}

/// Representation of a common table expression, which provides a short-hand notation for
/// queries within the context of a single statement.
pub struct CommonTableExpression {
    /// the name under which we will refer to these query results in the remainder of the query
    /// that is using this common table expression
    pub identifier: String,

    /// column names that can define a re-ordering of the values returned by the enclosed query
    pub column_names: Option<Vec<String>>,

    /// a query statement that defines the values for this common table expression
    pub query: SelectStatement,
}

/// Representation of a select statement.
pub struct SelectStatement {
    /// 0 or more comon table expressions, that can be referenced by the main query expression
    pub common: Vec<CommonTableExpression>,

    /// the query expression
    pub expr: Box<SetExpression>,

    /// if non-empty, an sort-order that is applied to the rows returned as result
    pub order_by: Vec<Ordering>,

    /// an optional limit clause, which can restrict the rows returned to a window within the
    /// set of rows as generated by `expr` and `order_by`.
    pub limit: Option<Limit>,
}

/// Represenatation of a delete statement
pub struct DeleteStatement {
    /// the name of the table from which rows should be deleted
    pub table_name: Vec<String>,

    /// a predicate defining the rows to delete
    pub where_expr: Option<Box<Expression>>,
}

/// Representation of an update statement
pub struct UpdateStatement {
    /// the qualified table name
    pub table_name: Vec<String>,

    /// assignments providing new values for table columns
    pub assignments: Vec<Assignment>,

    /// a predicate restricting the set of columns to which the update should be applied
    pub where_expr: Option<Box<Expression>>,
}

/// Rerpresentation of an attach statement
pub struct AttachStatement {
    /// an optional schema name within which we are defining a new table mapped to an external file
    pub schema: Option<String>,

    /// the table name within the previous (or default) schema
    pub name: String,

    /// the file system path of the external file to be attached as table
    pub path: String,
}

impl AttachStatement {
    pub fn new(schema: Option<String>, name: String, path: String) -> AttachStatement {
        AttachStatement { schema, name, path }
    }
}

/// Representation of a describe statememnt
pub struct DescribeStatement {
    /// an optional schema of the object to describe
    pub schema: Option<String>,

    /// the name of the object to describe
    pub name: String,
}

impl DescribeStatement {
    pub fn new(schema: Option<String>, name: String) -> DescribeStatement {
        DescribeStatement { schema, name }
    }
}

/// Assignment used as part of an Update statement. One or more columns are updated with
/// the provided expression value.
pub struct Assignment {
    pub columns: Vec<String>,
    pub expr: Box<Expression>,
}

pub enum SelectMode {
    All,
    Distinct,
}

/// Representation of a SetExpression, a collection of rows, each having one or more columns.
pub enum SetExpression {
    /// Literal row values
    Values(Vec<Vec<Box<Expression>>>),

    /// Query result as `SetExpression`
    Query {
        mode: SelectMode,
        columns: ResultColumns,
        from: Vec<Box<TableExpression>>,
        where_expr: Option<Box<Expression>>,
        group_by: Option<GroupBy>,
    },

    /// Binary operation on two `SetExpression` values
    Op {
        op: SetOperator,
        left: Box<SetExpression>,
        right: Box<SetExpression>,
    },
}

/// Representations of base queries
pub enum TableExpression {
    /// The row set of a given table; possibly providing an alias
    Named {
        /// the qualified table name
        name: Vec<String>,

        /// an alias to refer to the row set within this expression
        alias: Option<String>,
    },
    /// A nested select statement
    Select {
        /// a nested select statement
        select: SelectStatement,

        /// an alias to refer to the row set within this expression
        alias: Option<String>,
    },
    /// The Join of two `TableExpression` values
    Join {
        /// the left table expression to join
        left: Box<TableExpression>,

        /// the right table expression to join
        right: Box<TableExpression>,

        /// the join operator
        op: JoinOperator,

        /// the join constraint, specifying what conditions need to apply for joining two rows
        constraint: JoinConstraint,
    },
}

/// Representation of a join constraint
pub enum JoinConstraint {
    /// an expression describing the contraint
    Expr(Box<Expression>),

    /// join constraints provided via column value constraints
    Columns(Vec<String>),
}

/// Join operators
pub enum JoinOperator {
    /// Regular join
    Join(JoinType),

    /// Natural join
    Natural(JoinType),

    /// Cross join
    Cross,
}

/// Join types
pub enum JoinType {
    /// Inner join
    Inner,

    /// Left (outer) join
    Left,

    /// Right (outer) join
    Right,

    /// Full (outer) join
    Full,
}

/// Representation of result columns in a select statement
pub enum ResultColumns {
    /// All columns ('*')
    All,

    /// Result column specification
    List(Vec<Box<ResultColumn>>),
}

/// Representation of a single result column specification
pub enum ResultColumn {
    /// All columns from a given named schema object
    AllFrom(String),

    /// An expression
    Expr {
        /// the expression to evaluate
        expr: Box<Expression>,

        /// an optional column name in the resulting row set
        rename: Option<String>,
    },
}

/// Representation of grouping of result sets
pub struct GroupBy {
    /// One or more expressions that define the buckets for grouping
    pub groupings: Vec<Box<Expression>>,

    /// an optional constraint to limit the groups to collect rows for
    pub having: Option<Box<Expression>>,
}

/// Possible binary operators on row sets
pub enum SetOperator {
    /// Intersection operation
    Intersect,

    /// Set minus operation
    Except,

    /// Union of distinct values
    Union,

    /// Union including possible duplicates occuring on both sides
    UnionAll,
}

/// Possible unary operators for simple expressions
pub enum UnaryOperator {
    /// Numeric negation
    Negate,

    /// Logical inversion
    Not,

    /// Null check
    IsNull,
}

/// Binary operators for simple expressions
pub enum BinaryOperator {
    /// Numeric multiplication
    Multiply,

    /// Numeric division
    Divide,

    /// Numeric addition
    Add,

    /// Numeric subtraction
    Subtract,

    /// Concatenation of character sequences
    Concat,

    /// Logical and
    And,

    /// Logical or
    Or,
}

/// Comparison operators
pub enum ComparisonOperator {
    /// Equality
    Equal,

    /// Inquality
    NotEqual,

    /// Less than
    LessThan,

    /// Less than or equal to
    LessEqual,

    /// Greater than
    GreaterThan,

    /// Greater than or equal to
    GreaterEqual,

    /// Like operator (string matching)
    Like,
}

/// Scalar expressions
pub enum Expression {
    /// a literal value
    Literal(Literal),

    /// a qualified name referring to an attribute of a bound relation
    QualifiedIdentifier(Vec<String>),

    /// tuple construction
    MakeTuple(Vec<Box<Expression>>),

    /// nested select statement
    Select(SelectStatement),

    /// unary operation
    Unary {
        op: UnaryOperator,
        expr: Box<Expression>,
    },

    /// Binary operation
    Binary {
        op: BinaryOperator,
        left: Box<Expression>,
        right: Box<Expression>,
    },

    /// Comparison operation
    Comparison {
        op: ComparisonOperator,
        left: Box<Expression>,
        right: Box<Expression>,
    },

    /// Set membership test
    In {
        expr: Box<Expression>,
        set: SetSpecification,
    },

    /// Range check
    Between {
        expr: Box<Expression>,
        lower: Box<Expression>,
        upper: Box<Expression>,
    },

    /// Case statement
    Case {
        expr: Option<Box<Expression>>,
        when_part: Vec<WhenClause>,
        else_part: Option<Box<Expression>>,
    },
}

/// Specification of the containing set within a set membership expression
pub enum SetSpecification {
    /// Rows returned by a select statement
    Select(SelectStatement),

    /// List of expressions
    List(Vec<Box<Expression>>),

    /// a qualified name specifying a collection
    Name(Vec<String>),
}

/// Representaion of a when clause used inside a case expression
pub struct WhenClause {
    /// guard statement determining when this claause applies
    pub guard: Box<Expression>,

    /// the guarded expression to evaluate when this clause applies
    pub body: Box<Expression>,
}

/// Literal values
pub enum Literal {
    /// String literal
    StringLiteral(String),

    /// Numeric literal
    NumericLiteral(String),

    /// the NULL value
    Null,

    /// the current time
    CurrentTime,

    /// the current date
    CurrentDate,

    /// the current timestamp
    CurrentTimestamp,

    /// DATE literal
    DateLiteral(String),

    /// TIME literal
    TimeLiteral(String),

    /// TIMESTAMP literal
    TimestampLiteral(String),
}

/// Sort ordering direction
pub enum OrderingDirection {
    /// Sort in ascending order
    Ascending,

    /// Sort in descending order
    Descending,
}

/// Specification of a sort order
pub struct Ordering {
    /// an expression evaluating to the sort key
    pub expr: Box<Expression>,

    /// an optional collation to use for string comparisons
    pub collation: Option<String>,

    /// Sort ordering direction
    pub direction: OrderingDirection,
}

/// Limits for a limit clause
pub struct Limit {
    /// number of rows to return
    pub number_rows: Box<Expression>,

    /// number of rows to skip
    pub offset_value: Option<Box<Expression>>,
}

/// Helper function to append an item to a vector
pub fn append<T>(list: Vec<T>, item: T) -> Vec<T> {
    let mut result = list;
    result.push(item);
    result
}

#[derive(Clone, Debug)]
pub enum ScalarType {
    Tuple(Vec<ScalarType>),

    Scalar { typ: types::DataType, is_null: bool },
}

impl ScalarType {
    fn is_compatible(&self, other: &ScalarType) -> Result<bool, Error> {
        match (self, other) {
            (
                &ScalarType::Scalar {
                    typ: typ1,
                    is_null: null1,
                },
                &ScalarType::Scalar {
                    typ: typ2,
                    is_null: null2,
                },
            ) => {
                if typ1 == typ2 {
                    Ok(null1 | null2)
                } else {
                    Err(Error::from("Incompatible types"))
                }
            }
            (&ScalarType::Tuple(ref tuple1), &ScalarType::Tuple(ref tuple2)) => {
                if tuple1.len() != tuple2.len() {
                    return Err(Error::from(
                        "Incompatible tuple types due to different lengths",
                    ));
                }

                tuple1
                    .iter()
                    .zip(tuple2.iter())
                    .fold(Ok(false), |result, (ref left, ref right)| {
                        let item_result = left.is_compatible(right);
                        if result.is_err() {
                            result
                        } else if item_result.is_err() {
                            item_result
                        } else {
                            Ok(result.unwrap() & item_result.unwrap())
                        }
                    })
            }
            _ => Err(Error::from("Incompatible types")),
        }
    }
}

enum ScalarContextSymbol {
    // a unique attribute that can be accessed directly
    Attribute(ScalarType),

    // a conflict of attribute from different relations
    AttributeConflict,

    // a relation with its constituent attributes
    Relation(collections::HashMap<String, ScalarType>),
}

/// A context of bindings used to evaluate a type; for scalars, we are interested in bindings for
/// identifiers of attributes of rows within a relation.
pub struct ScalarContext<'a> {
    // reference to an underlying SetContext
    set_context: &'a SetContext<'a>,

    // need a way to capture qualified attributes and attributes without qualification
    symbols: collections::HashMap<String, ScalarContextSymbol>,
}

impl<'a> ScalarContext<'a> {
    fn new(set_context: &'a SetContext<'a>) -> Self {
        ScalarContext {
            set_context,
            symbols: collections::HashMap::new(),
        }
    }

    fn add_relation(
        &mut self,
        name: String,
        attributes: Vec<(String, ScalarType)>,
    ) -> Result<(), Error> {
        // add the individual attributes
        for &(ref key, ref value) in &attributes {
            match self.symbols.get(key) {
                None => mem::drop(
                    self.symbols
                        .insert(key.clone(), ScalarContextSymbol::Attribute(value.clone())),
                ),
                Some(&ScalarContextSymbol::Attribute(_)) => mem::drop(
                    self.symbols
                        .insert(key.clone(), ScalarContextSymbol::AttributeConflict),
                ),
                Some(&ScalarContextSymbol::AttributeConflict) => (),
                Some(&ScalarContextSymbol::Relation(_)) => (),
            }
        }

        // add the relationship entry
        let map: collections::HashMap<String, ScalarType> = attributes.into_iter().collect();

        match self.symbols.get(&name) {
            Some(&ScalarContextSymbol::Relation(_)) => {
                Err(Error::from(format!("Duplicate relation name '{}'", &name)))
            }
            _ => {
                mem::drop(
                    self.symbols
                        .insert(name, ScalarContextSymbol::Relation(map)),
                );
                Ok(())
            }
        }
    }

    fn infer_type(&self, qualified_name: &[String]) -> Result<ScalarType, Error> {
        match qualified_name.len() {
            1 => match self.symbols.get(&qualified_name[0]) {
                None => Err(Error::from(format!(
                    "Undefined attribute name '{}'",
                    &qualified_name[0]
                ))),
                Some(&ScalarContextSymbol::Attribute(ref typ)) => Ok(typ.clone()),
                Some(&ScalarContextSymbol::AttributeConflict) => Err(Error::from(format!(
                    "Ambiguous attribute name '{}'",
                    &qualified_name[0]
                ))),
                Some(&ScalarContextSymbol::Relation(_)) => Err(Error::from(format!(
                    "Name '{}' refers to a relation",
                    &qualified_name[0]
                ))),
            },
            2 => match self.symbols.get(&qualified_name[0]) {
                Some(&ScalarContextSymbol::Relation(ref attributes)) => attributes
                    .get(&qualified_name[1])
                    .map(|t| t.clone())
                    .ok_or_else(|| {
                        Error::from(format!(
                            "Name '{}' does not refer to an attribute of relation '{}'",
                            &qualified_name[1], &qualified_name[0]
                        ))
                    }),
                _ => Err(Error::from(format!(
                    "Name '{}' does not refer to a relation",
                    &qualified_name[0]
                ))),
            },
            _ => Err(Error::from(
                "Qualfied name needs to have 1 or 2 path components",
            )),
        }
    }
}

impl Expression {
    fn infer_type(&self, context: &ScalarContext) -> Result<ScalarType, Error> {
        match self {
            &Expression::Literal(ref literal) => Ok(literal.infer_type()),

            /// a qualified name referring to an attribute of a bound relation
            &Expression::QualifiedIdentifier(ref qualident) => context.infer_type(qualident),

            /// tuple construction
            &Expression::MakeTuple(ref exprs) => {
                let result: Result<Vec<ScalarType>, Error> = exprs
                    .into_iter()
                    .map(|ref expr| expr.infer_type(context))
                    .collect();

                Ok(ScalarType::Tuple(result?))
            }

            /// unary operation
            &Expression::Unary { ref op, ref expr } => {
                let expr_type = expr.infer_type(context)?;

                match op {
                    &UnaryOperator::Negate => {
                        // should be a numeric type
                        match expr_type {
                            ScalarType::Scalar {
                                typ: types::DataType::Numeric,
                                is_null,
                            } => Ok(expr_type.clone()),
                            _ => Err(Error::from(
                                "Negate operation can only be applied to numeric type",
                            )),
                        }
                    }
                    &UnaryOperator::Not => {
                        // should be a logical type
                        match expr_type {
                            ScalarType::Scalar {
                                typ: types::DataType::Logical,
                                is_null,
                            } => Ok(expr_type.clone()),
                            _ => Err(Error::from(
                                "Not operation can only be applied to logical type",
                            )),
                        }
                    }
                    &UnaryOperator::IsNull => match expr_type {
                        ScalarType::Scalar { typ, is_null } => Ok(expr_type.clone()),
                        _ => Err(Error::from(
                            "Null test operation can only be applied to scalar type",
                        )),
                    },
                }
            }

            /// Binary operation
            &Expression::Binary {
                ref op,
                ref left,
                ref right,
            } => {
                let left_type = left.infer_type(context)?;
                let right_type = right.infer_type(context)?;

                match op {
                    &BinaryOperator::Multiply
                    | &BinaryOperator::Divide
                    | &BinaryOperator::Add
                    | &BinaryOperator::Subtract => {
                        // should be a numeric type
                        match (left_type, right_type) {
                            (
                                ScalarType::Scalar {
                                    typ: types::DataType::Numeric,
                                    is_null: null1,
                                },
                                ScalarType::Scalar {
                                    typ: types::DataType::Numeric,
                                    is_null: null2,
                                },
                            ) => Ok(ScalarType::Scalar {
                                typ: types::DataType::Numeric,
                                is_null: null1 | null2,
                            }),
                            _ => Err(Error::from(
                                "Arithmetic operation can only be applied to numeric type",
                            )),
                        }
                    }

                    &BinaryOperator::Concat => {
                        // should be a varchar type
                        match (left_type, right_type) {
                            (
                                ScalarType::Scalar {
                                    typ: types::DataType::Varchar,
                                    is_null: null1,
                                },
                                ScalarType::Scalar {
                                    typ: types::DataType::Varchar,
                                    is_null: null2,
                                },
                            ) => Ok(ScalarType::Scalar {
                                typ: types::DataType::Varchar,
                                is_null: null1 | null2,
                            }),
                            _ => Err(Error::from(
                                "Concat operation can only be applied to string type",
                            )),
                        }
                    }

                    &BinaryOperator::And | &BinaryOperator::Or => {
                        // should be a logical type
                        match (left_type, right_type) {
                            (
                                ScalarType::Scalar {
                                    typ: types::DataType::Logical,
                                    is_null: null1,
                                },
                                ScalarType::Scalar {
                                    typ: types::DataType::Logical,
                                    is_null: null2,
                                },
                            ) => Ok(ScalarType::Scalar {
                                typ: types::DataType::Logical,
                                is_null: null1 | null2,
                            }),
                            _ => Err(Error::from(
                                "Logical operation can only be applied to logical type",
                            )),
                        }
                    }
                }
            }

            /// Comparison operation
            &Expression::Comparison {
                ref op,
                ref left,
                ref right,
            } => {
                let left_type = left.infer_type(context)?;
                let right_type = right.infer_type(context)?;

                match op {
                    &ComparisonOperator::Equal | &ComparisonOperator::NotEqual => {
                        match left_type.is_compatible(&right_type) {
                            Ok(is_null) => Ok(ScalarType::Scalar {
                                typ: types::DataType::Logical,
                                is_null,
                            }),
                            Err(err) => Err(err),
                        }
                    }

                    &ComparisonOperator::LessThan
                    | &ComparisonOperator::LessEqual
                    | &ComparisonOperator::GreaterThan
                    | &ComparisonOperator::GreaterEqual => match (left_type, right_type) {
                        (
                            ScalarType::Scalar {
                                typ: typ1,
                                is_null: null1,
                            },
                            ScalarType::Scalar {
                                typ: typ2,
                                is_null: null2,
                            },
                        ) => {
                            if typ1 == typ2 && typ1.is_ordered() {
                                Ok(ScalarType::Scalar {
                                    typ: types::DataType::Logical,
                                    is_null: null1 | null2,
                                })
                            } else {
                                Err(Error::from("Operands of comparison operator need be of an ordered scalar type"))
                            }
                        }
                        _ => Err(Error::from(
                            "Operands of comparison operator need be of scalar type",
                        )),
                    },

                    &ComparisonOperator::Like => match (left_type, right_type) {
                        (
                            ScalarType::Scalar {
                                typ: types::DataType::Varchar,
                                is_null: null1,
                            },
                            ScalarType::Scalar {
                                typ: types::DataType::Varchar,
                                is_null: null2,
                            },
                        ) => Ok(ScalarType::Scalar {
                            typ: types::DataType::Logical,
                            is_null: null1 | null2,
                        }),
                        _ => Err(Error::from(
                            "Operands of Like operator need be of string type",
                        )),
                    },
                }
            }

            /// Range check
            &Expression::Between {
                ref expr,
                ref lower,
                ref upper,
            } => {
                let expr_type = expr.infer_type(context)?;
                let lower_type = lower.infer_type(context)?;
                let upper_type = upper.infer_type(context)?;

                match (expr_type, lower_type, upper_type) {
                    (
                        ScalarType::Scalar {
                            typ: typ1,
                            is_null: null1,
                        },
                        ScalarType::Scalar {
                            typ: typ2,
                            is_null: null2,
                        },
                        ScalarType::Scalar {
                            typ: typ3,
                            is_null: null3,
                        },
                    ) => {
                        if typ1 == typ2 && typ1 == typ3 && typ1.is_ordered() {
                            Ok(ScalarType::Scalar {
                                typ: types::DataType::Logical,
                                is_null: null1 | null2 | null3,
                            })
                        } else {
                            Err(Error::from("Operands of range check expression need be of an ordered scalar type"))
                        }
                    }
                    _ => Err(Error::from(
                        "Operands of range check expression need be of scalar type",
                    )),
                }
            }

            /// Case statement; guards are predicates
            &Expression::Case {
                expr: None,
                ref when_part,
                ref else_part,
            } => {
                // All when part clauses must have a guard that evaluates to a logical value
                let _ = fold_err((), when_part.iter(), |_, ref clause| {
                    let guard_type = clause.guard.infer_type(&context)?;

                    match guard_type {
                        ScalarType::Scalar {
                            typ: types::DataType::Logical,
                            is_null: _,
                        } => Ok(()),
                        _ => Err(Error::from("Case guard must evaluate to a logical type")),
                    }
                });

                // All when part clauses must have a body that evaluates to the same type
                assert!(when_part.len() >= 1);
                let mut iter = when_part.iter();
                let result_init_type = iter.next().unwrap().body.infer_type(&context)?;
                let result_type = fold_err(result_init_type, iter, |typ, ref clause| {
                    let body_type = clause.body.infer_type(&context)?;
                    let is_null1 = body_type.is_compatible(&typ)?;
                    match body_type {
                        ScalarType::Tuple(_) => Err(Error::from(
                            "THEN clause must evaluate to scalar expression",
                        )),
                        ScalarType::Scalar { typ, is_null } => Ok(ScalarType::Scalar {
                            typ,
                            is_null: is_null | is_null1,
                        }),
                    }
                })?;

                // If the else part is provided, it must be compatible with the type of all the clauses
                match (else_part, &result_type) {
                    (
                        &None,
                        &ScalarType::Scalar {
                            ref typ,
                            is_null: _,
                        },
                    ) => Ok(ScalarType::Scalar {
                        typ: typ.clone(),
                        is_null: true,
                    }),
                    (&Some(ref body), &ScalarType::Scalar { ref typ, is_null }) => {
                        let body_type = body.infer_type(&context)?;
                        let is_null1 = body_type.is_compatible(&result_type)?;
                        Ok(ScalarType::Scalar {
                            typ: *typ,
                            is_null: is_null1 | is_null,
                        })
                    }
                    _ => panic!("Should have covered all cases"),
                }
            }

            /// Case statement;switch on expr value
            &Expression::Case {
                expr: Some(ref expr),
                ref when_part,
                ref else_part,
            } => {
                // Type of expression must allow for scalar comparison
                let expr_type = expr.infer_type(&context)?;

                // All when part clauses must have a guard that evaluates to the same type as expr
                let _ = fold_err((), when_part.iter(), |_, ref clause| {
                    let guard_type = clause.guard.infer_type(&context)?;

                    if guard_type.is_compatible(&expr_type)? {
                        Ok(())
                    } else {
                        Err(Error::from(
                            "Guard expression is incompatible with CASE expression",
                        ))
                    }
                });

                // All when part clauses must have a body that evalujates to the same type
                assert!(when_part.len() >= 1);
                let mut iter = when_part.iter();
                let result_init_type = iter.next().unwrap().body.infer_type(&context)?;
                let result_type = fold_err(result_init_type, iter, |typ, ref clause| {
                    let body_type = clause.body.infer_type(&context)?;
                    let is_null1 = body_type.is_compatible(&typ)?;
                    match body_type {
                        ScalarType::Tuple(_) => Err(Error::from(
                            "THEN clause must evaluate to scalar expression",
                        )),
                        ScalarType::Scalar { typ, is_null } => Ok(ScalarType::Scalar {
                            typ,
                            is_null: is_null | is_null1,
                        }),
                    }
                })?;

                // If the else part is provided, it must be compatible with the type of all the clauses
                match (else_part, &result_type) {
                    (
                        &None,
                        &ScalarType::Scalar {
                            ref typ,
                            is_null: _,
                        },
                    ) => Ok(ScalarType::Scalar {
                        typ: typ.clone(),
                        is_null: true,
                    }),
                    (&Some(ref body), &ScalarType::Scalar { ref typ, is_null }) => {
                        let body_type = body.infer_type(&context)?;
                        let is_null1 = body_type.is_compatible(&result_type)?;
                        Ok(ScalarType::Scalar {
                            typ: *typ,
                            is_null: is_null1 | is_null,
                        })
                    }
                    _ => panic!("Should have covered all cases"),
                }
            }

            /// Set membership test; set should evaluate to a row set with a single column
            &Expression::In { ref expr, ref set } => {
                let expr_type = expr.infer_type(context)?;
                let set_type = set.infer_type(&context.set_context)?;

                if set_type.attributes.len() != 1 {
                    return Err(Error::from(
                        "Set for IN expression needs to evaluate to row set with a single column",
                    ));
                }

                if expr_type.is_compatible(&ScalarType::Scalar {
                    typ: set_type.attributes[0].typ,
                    is_null: set_type.attributes[0].is_null,
                })? {
                    Ok(ScalarType::Scalar {
                        typ: types::DataType::Logical,
                        is_null: false,
                    })
                } else {
                    Err(Error::from("Incompatible types for IN expression"))
                }
            }

            /// nested select statement
            ///
            /// should evaluate to a row set with a single column (and single row upon execution)
            &Expression::Select(ref select) => {
                let select_type = select.infer_type(&context.set_context)?;
                if select_type.attributes.len() == 1 {
                    Ok(ScalarType::Scalar {
                        typ: select_type.attributes[0].typ,
                        is_null: select_type.attributes[0].is_null,
                    })
                } else {
                    Err(Error::from(
                        "SELECT statement should evaluate to a single column",
                    ))
                }
            }
        }
    }
}

fn fold_err<S, I: iter::Iterator, F: Fn(S, I::Item) -> Result<S, Error>>(
    state: S,
    iter: I,
    func: F,
) -> Result<S, Error> {
    let mut result = state;

    for item in iter {
        match func(result, item) {
            Ok(val) => result = val,
            Err(err) => return Err(err),
        }
    }

    Ok(result)
}

impl Literal {
    fn infer_type(&self) -> ScalarType {
        match self {
            &Literal::StringLiteral(_) => ScalarType::Scalar {
                typ: types::DataType::Varchar,
                is_null: false,
            },

            /// Numeric literal
            &Literal::NumericLiteral(_) => ScalarType::Scalar {
                typ: types::DataType::Numeric,
                is_null: false,
            },

            /// the NULL value
            &Literal::Null => ScalarType::Scalar {
                typ: types::DataType::Generic,
                is_null: true,
            },

            /// the current time
            &Literal::CurrentTime => ScalarType::Scalar {
                typ: types::DataType::Time,
                is_null: false,
            },

            /// the current date
            &Literal::CurrentDate => ScalarType::Scalar {
                typ: types::DataType::Date,
                is_null: false,
            },

            /// the current timestamp
            &Literal::CurrentTimestamp => ScalarType::Scalar {
                typ: types::DataType::Timestamp,
                is_null: false,
            },

            /// DATE literal
            &Literal::DateLiteral(_) => ScalarType::Scalar {
                typ: types::DataType::Date,
                is_null: false,
            },

            /// TIME literal
            &Literal::TimeLiteral(_) => ScalarType::Scalar {
                typ: types::DataType::Time,
                is_null: false,
            },

            /// TIMESTAMP literal
            &Literal::TimestampLiteral(_) => ScalarType::Scalar {
                typ: types::DataType::Timestamp,
                is_null: false,
            },
        }
    }
}

struct Attribute {
    name: String,
    typ: types::DataType,
    is_null: bool,
}

pub struct RowType {
    attributes: Vec<Attribute>,
    primary_key: Vec<String>,
    order_by: Vec<(String, OrderingDirection)>,
}

/// A context of bindings used to evaluate a type; for set expressions, we are interested in bindings
/// of identifiers for relations.
pub struct SetContext<'a> {
    // need a reference to a schema
    schema: &'a schema::Schema,

    // need a way to capture common table expression names
    table_expression: collections::BTreeMap<String, RowType>,
}

impl<'a> SetContext<'a> {
    fn new(schema: &'a schema::Schema) -> Self {
        SetContext {
            schema: schema,
            table_expression: collections::BTreeMap::new(),
        }
    }

    fn define_relation(&mut self, name: String, typ: RowType) -> Result<(), Error> {
        match self.table_expression.insert(name.clone(), typ) {
            None => Ok(()),
            Some(_) => Err(Error::from(format!(
                "Duplicate name '{}' for common table expression",
                name
            ))),
        }
    }

    // Convenience function to construct SetContext from Schema and iterator over common table expressions
    fn initialize<'c, I>(schema: &'a schema::Schema, cte: I) -> Result<Self, Error>
    where
        I: iter::IntoIterator<Item = &'c CommonTableExpression>,
    {
        let mut result = Self::new(schema);

        for item in cte {
            let row_type = item.infer_type(&result)?;
            result.define_relation(item.identifier.clone(), row_type)?;
        }

        Ok(result)
    }
}

impl SetExpression {
    fn infer_type(&self, context: &SetContext) -> Result<RowType, Error> {
        unimplemented!()
    }
}

impl TableExpression {
    fn infer_type(&self, context: &SetContext) -> Result<ScalarContext, Error> {
        unimplemented!()
    }
}

impl SetSpecification {
    fn infer_type(&self, context: &SetContext) -> Result<RowType, Error> {
        unimplemented!()
    }
}

impl SelectStatement {
    fn infer_type(&self, context: &SetContext) -> Result<RowType, Error> {
        unimplemented!()
    }
}

impl CommonTableExpression {
    fn infer_type(&self, context: &SetContext) -> Result<RowType, Error> {
        // infer the type of the query
        // apply the optional column subsetting/reordering
        unimplemented!()
    }
}
